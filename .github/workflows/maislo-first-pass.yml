name: Maislo Full Pass (ALL + Variants, fixed metafield types)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "*/30 * * * *"

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install requests

      - name: Run FULL PASS (products + variants)
        env:
          SHOP_DOMAIN: ${{ secrets.SHOP_DOMAIN }}
          SHOP_TOKEN:  ${{ secrets.SHOP_TOKEN }}
          SHOP_API_VERSION: ${{ secrets.SHOP_API_VERSION }}
          RATE_LIMIT_SLEEP: "1.0"
          PROGRESS_EVERY: "25"
          SHOW_EVERY_ITEM: "0"
          PASS_MARK: "full-pass-1"
          FORCE_REPROCESS: "1"
        run: |
          python - << 'PY'
          import os, re, time, html, unicodedata, requests
          from datetime import datetime, timezone

          SHOP_DOMAIN = os.environ["SHOP_DOMAIN"]
          TOKEN = os.environ["SHOP_TOKEN"]
          API_VERSION = os.environ.get("SHOP_API_VERSION","2024-07")
          RATE_LIMIT_SLEEP = float(os.environ.get("RATE_LIMIT_SLEEP","1.0"))
          PROGRESS_EVERY = int(os.environ.get("PROGRESS_EVERY","25"))
          SHOW_EVERY_ITEM = os.environ.get("SHOW_EVERY_ITEM","0")=="1"
          PASS_MARK = os.environ.get("PASS_MARK","").strip()
          FORCE_REPROCESS = os.environ.get("FORCE_REPROCESS","0")=="1"

          S = requests.Session()
          S.headers.update({"X-Shopify-Access-Token": TOKEN, "Content-Type":"application/json","Accept":"application/json"})

          # ---------- HTTP helpers ----------
          def req(m,u,**k):
            tries=0
            while True:
              r = S.request(m,u,timeout=60,**k)
              if r.status_code==429:
                tries+=1
                retry_after = r.headers.get("Retry-After")
                if retry_after:
                  try: wait=float(retry_after)
                  except: wait=max(1.0,RATE_LIMIT_SLEEP)
                else:
                  wait=max(1.0,RATE_LIMIT_SLEEP)
                time.sleep(wait)
                if tries<8: continue
                return r
              bucket=r.headers.get("X-Shopify-Shop-Api-Call-Limit","")
              try:
                used,total=[int(x) for x in bucket.split("/")]
                if used>=total-4: time.sleep(1.0)
              except: pass
              time.sleep(RATE_LIMIT_SLEEP)
              return r

          def next_page_info(resp):
            link = resp.headers.get("Link","") or ""
            m = re.search(r'<[^>]*[?&]page_info=([^&>]+)>; rel="next"', link)
            return m.group(1) if m else None

          # ---------- Text utils ----------
          TAG_RE = re.compile(r"<[^>]+>")
          def html_to_text(s):
            if not s: return ""
            s = html.unescape(s); s = TAG_RE.sub(" ", s)
            return re.sub(r"\s{2,}"," ", s).strip()

          def strip_accents(s): 
            return "".join(c for c in unicodedata.normalize("NFD", s or "") if unicodedata.category(c)!="Mn")

          # ---------- Normalizers ----------
          def normalize_brand(v):
            if not v: return ""
            v=re.sub(r"\s{2,}"," ",v.strip())
            if v.isupper() and len(v)<=6: return v
            return " ".join([p.capitalize() if p.islower() else p for p in v.split(" ")])

          COLOR_MAP={"negro":"Black","noir":"Black","black":"Black","nero":"Black","blanco":"White","bianco":"White","white":"White","gris":"Gray","grigio":"Gray","grey":"Gray","azul":"Blue","blu":"Blue","bleu":"Blue","rojo":"Red","rosso":"Red","rouge":"Red","verde":"Green","vert":"Green","amarillo":"Yellow","giallo":"Yellow","jaune":"Yellow","naranja":"Orange","arancione":"Orange","marron":"Brown","marrón":"Brown","marrone":"Brown","beige":"Beige","rosa":"Pink","rose":"Pink","fucsia":"Pink","morado":"Purple","viola":"Purple","multicolor":"Multicolor","multi":"Multicolor","varios":"Multicolor"}
          def normalize_color(v):
            if not v: return ""
            vl=strip_accents(v.strip().lower())
            for t in re.split(r"[\/,\-\s]+",vl):
              if t in COLOR_MAP: return COLOR_MAP[t]
            return v.strip().title()

          def extract_color_from_options(p):
            for opt in p.get("options",[]):
              name=(opt.get("name") or "").lower()
              if name in ("color","colour","couleur","colore","coloris"):
                vals=opt.get("values") or []
                if vals: return vals[0]
            return ""

          def guess_gender(tags):
            t=(tags or "").lower()
            if any(x in t for x in ["mujer","women","femme","lady"]): return "Mujer"
            if any(x in t for x in ["hombre","men","homme"]): return "Hombre"
            if "niña" in t or "girl" in t: return "Niña"
            if "niño" in t or "boy" in t: return "Niño"
            return "Unisex"

          KW={
            "perfumes":["perfume","fragancia","colonia","eau de parfum","eau de toilette","edp","edt","after shave","aftershave","parfum","fragrance","cologne"],
            "calzado":["zapat","zapato","bota","botin","sandalia","chancla","mocasin","zueco","alpargata","tacon","sneaker","shoe","boot","sandal","loafer","derby","oxford","heel","pump","trainer","chaussure","botte","sandale","mocassin","stivale","scarpa","sandalo"],
            "bolsos":["bolso","mochila","bandolera","riñonera","rinonera","tote","shopper","clutch","satchel","hobo","bag","backpack","crossbody","handbag","pouch","sac","pochette"],
            "relojes":["reloj","cronografo","smartwatch","analogico","digital","watch","wristwatch","chronograph","montre","chronographe"],
            "complementos":["cinturon","cinturón","bufanda","foulard","pañuelo","gorra","sombrero","guante","gafas","sunglasses","cartera","wallet","corbata","tie","pajarita","calcetin","calcetines","medias","diadema","paraguas","umbrella"],
            "ropa":["camiseta","camisa","polo","jersey","sudadera","pantal","pantalon","vaquero","jean","denim","falda","vestido","short","chaqueta","abrigo","chaleco","mono","top","blusa","leggings","pijama","lenceria","bañador","bikini","parka","trench","blazer","jacket","coat","dress","skirt","hoodie","t-shirt"],
            "hogar":["hogar","home","bedding","toalla","sabana","sábana","funda","cojin","cojín","edredon","colcha","almohada","manta","cortina","alfombra","duvet","pillow","blanket","curtain","rug"]
          }
          NEG={"relojes":["correa","strap","band"],"bolsos":["wallet","cartera"]}

          def detect_category(ptype,tags,title):
            t=strip_accents(" ".join([ptype or "",tags or "",title or ""]).lower())
            order=["perfumes","calzado","bolsos","relojes","complementos","ropa","hogar"]
            for cat in order:
              kws=[strip_accents(x) for x in KW[cat]]
              if any(k in t for k in kws):
                if any(strip_accents(n) in t for n in NEG.get(cat,[])): continue
                return cat
            return "otros"

          # ---------- Metafields helpers ----------
          # Tipos forzados por clave (para coincidir con tus definiciones de Shopify)
          PRODUCT_META_TYPE = {
            ("custom","brand"): "single_line_text_field",
            ("custom","model"): "single_line_text_field",
            ("custom","gender"): "single_line_text_field",
            ("custom","category"): "single_line_text_field",
            ("custom","color"): "single_line_text_field",
            ("custom","tech_description"): "multi_line_text_field",
            ("custom","processed_pass"): "single_line_text_field",
          }

          def sanitize_for_type(value, mf_type):
            if value is None: return value
            if mf_type == "single_line_text_field" and isinstance(value, str):
              v = re.sub(r"\s+", " ", value).strip()
              # por seguridad, cortamos a 255 chars
              return v[:255]
            if mf_type == "number_decimal":
              try: return str(float(value))
              except: return None
            return value

          def get_product_metafields(pid):
            url=f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/products/{pid}/metafields.json"
            r=req("GET",url)
            d={}
            if r.ok:
              for m in r.json().get("metafields",[]):
                d[f"{m.get('namespace')}.{m.get('key')}"]={"id":m.get("id"),"value":m.get("value"),"type":m.get("type")}
            return d

          def upsert_product_metafield(pid, namespace, key, value):
            metas=get_product_metafields(pid)
            existing=metas.get(f"{namespace}.{key}")
            # decide type: existing type or forced by map
            desired_type = (existing or {}).get("type") or PRODUCT_META_TYPE.get((namespace,key)) or "single_line_text_field"
            value = sanitize_for_type(value, desired_type)
            if value in (None,"",[]): return

            if existing and existing.get("id"):
              mid=existing["id"]
              url=f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/metafields/{mid}.json"
              payload={"metafield":{"id":mid,"value":value}}
              # si la API exige type, lo ponemos igual que existing
              if existing.get("type"): payload["metafield"]["type"]=existing["type"]
              r=req("PUT",url,json=payload)
              if not r.ok: print("metafield PUT error",pid,namespace,key,r.status_code,r.text)
              return

            url=f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/metafields.json"
            payload={"metafield":{
              "namespace":namespace,"key":key,"value":value,"type":desired_type,
              "owner_resource":"product","owner_id":pid
            }}
            r=req("POST",url,json=payload)
            if not r.ok and r.status_code!=422:
              print("metafield POST error",pid,namespace,key,r.status_code,r.text)

          def put_product(pid, payload):
            url=f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/products/{pid}.json"
            r=req("PUT",url,json={"product":payload})
            if not r.ok: print("update product error",pid,r.status_code,r.text)

          def put_variant(vid, payload):
            url=f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/variants/{vid}.json"
            r=req("PUT",url,json={"variant":payload})
            if not r.ok: print("update variant error",vid,r.status_code,r.text)

          def add_tag_if_missing(pid, current_tags: str, tag: str):
            tags_list=[t.strip() for t in (current_tags or "").split(",") if t.strip()]
            if tag not in tags_list:
              tags_list.append(tag)
              put_product(pid, {"id": pid, "tags": ", ".join(tags_list)})

          # ---------- Conteo (robusto) ----------
          def try_count():
            urls=[
              f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/products/count.json?status=any&published_status=any",
              f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/products/count.json?status=any",
              f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/products/count.json"
            ]
            for u in urls:
              r=req("GET",u)
              if r.ok:
                try:
                  c=int(r.json().get("count",0))
                  if c>=0: return c
                except: pass
            return 0

          total = try_count()
          print("Conteo total (aprox.):", total, flush=True)

          processed=0
          skipped=0
          page_info=None
          page_no=0
          start=time.time()

          while True:
            base=f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/products.json?limit=250&status=any&published_status=any"
            url = base + (f"&page_info={page_info}" if page_info else "")
            r=req("GET",url)
            if not r.ok:
              print("Fetch error:", r.status_code, r.text, flush=True); break

            prods=r.json().get("products",[])
            if not prods and page_info is None:
              base2=f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/products.json?limit=250&published_status=any"
              r2=req("GET",base2)
              prods=r2.json().get("products",[]) if r2.ok else []
              print(f"Reintento sin 'status': {len(prods)} productos", flush=True)
            if not prods:
              print("No hay más productos.", flush=True)
              break

            page_no += 1
            print(f"[Página {page_no}] cargada: {len(prods)} productos", flush=True)

            for p in prods:
              pid=p["id"]
              vendor=normalize_brand(p.get("vendor") or "")
              title=p.get("title") or ""
              tags=p.get("tags") or ""
              ptype=p.get("product_type") or ""
              color_opt=extract_color_from_options(p)
              metas=get_product_metafields(pid)

              if PASS_MARK and (metas.get("custom.processed_pass") or {}).get("value")==PASS_MARK and not FORCE_REPROCESS:
                skipped+=1
                if SHOW_EVERY_ITEM: print(f"SKIP pid={pid} (ya marcado {PASS_MARK})", flush=True)
                continue

              gender=guess_gender(tags)

              # --- PRODUCT metafields (tipos forzados) ---
              if vendor: upsert_product_metafield(pid, "custom", "brand", vendor)

              model=title.strip()
              if vendor and model.lower().startswith(vendor.lower()): model=model[len(vendor):].strip()
              if vendor: model=re.sub(re.escape(vendor), "", model, flags=re.I).strip()
              model=re.sub(r"\s{2,}"," ",model) or title
              upsert_product_metafield(pid, "custom", "model", model)
              upsert_product_metafield(pid, "custom", "gender", gender)

              body_html = p.get("body_html") or ""
              orig_html = (metas.get("custom.original_description") or {}).get("value") or ""
              tech_source = orig_html if orig_html.strip() else body_html
              tech_text = html_to_text(tech_source)
              if tech_text:
                upsert_product_metafield(pid, "custom", "tech_description", tech_text)

              existing = ((metas.get("custom.category") or {}).get("value") or "").strip()
              cat = strip_accents(existing).lower() if existing else detect_category(ptype,tags,title)
              upsert_product_metafield(pid, "custom", "category", (cat or "otros").capitalize())

              if color_opt:
                upsert_product_metafield(pid, "custom", "color", normalize_color(color_opt))

              # Body marketing
              c_txt=f" en color {normalize_color(color_opt)}" if color_opt else ""
              g_txt=f" ({gender})" if gender and gender!="Unisex" else ""
              b = vendor or "Maislo"; m=model or "Producto"
              if cat=="calzado": line=f"{m or 'Calzado'} de {b}{c_txt}{g_txt}. Diseño actual y versátil."
              elif cat=="bolsos": line=f"{m or 'Bolso'} de {b}{c_txt}{g_txt}. Práctico y con estilo."
              elif cat=="relojes": line=f"{m or 'Reloj'} de {b}{g_txt}{c_txt}. Detalle que eleva cualquier look."
              elif cat=="ropa": line=f"{m or 'Prenda'} de {b}{c_txt}{g_txt}. Fácil de combinar."
              elif cat=="complementos": line=f"{m or 'Accesorio'} de {b}{c_txt}{g_txt}. Toque final para tu outfit."
              elif cat=="hogar": line=f"{m or 'Artículo para el hogar'} de {b}{c_txt}. Confort y calidad."
              elif cat=="perfumes": line=f"{m or 'Fragancia'} de {b}. Aromas originales a precio outlet."
              else: line=f"{m or 'Producto'} de {b}{c_txt}{g_txt}."
              body=f"<p>{line} Auténtico outlet 100% original. Stock limitado.</p>"
              put_product(pid,{"id":pid,"body_html":body})

              # --- VARIANTES ---
              total_inventory=0
              for v in p.get("variants", []):
                inv = v.get("inventory_quantity")
                if isinstance(inv,int): total_inventory += inv
                vid = v["id"]
                price = float(v.get("price") or 0)
                cap = v.get("compare_at_price")
                barcode = v.get("barcode") or ""
                sku = v.get("sku") or ""

                # compare_at / msrp
                if cap not in (None,""):
                  try:
                    capf=float(cap)
                    if capf <= price:
                      put_variant(vid, {"id": vid, "compare_at_price": None})
                    else:
                      mf_url=f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/metafields.json"
                      payload={"metafield":{"namespace":"custom","key":"msrp","value":str(capf),"type":"number_decimal","owner_resource":"variant","owner_id":vid}}
                      rr=req("POST",mf_url,json=payload)
                      if not rr.ok and rr.status_code!=422:
                        print("metafield variant msrp error",vid,rr.status_code,rr.text)
                  except Exception:
                    pass

                # EAN / MPN
                if barcode:
                  mf_url=f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/metafields.json"
                  payload={"metafield":{"namespace":"custom","key":"ean","value":barcode,"type":"single_line_text_field","owner_resource":"variant","owner_id":vid}}
                  rr=req("POST",mf_url,json=payload)
                  if not rr.ok and rr.status_code!=422:
                    print("metafield variant ean error",vid,rr.status_code,rr.text)
                if sku:
                  mf_url=f"https://{SHOP_DOMAIN}/admin/api/{API_VERSION}/metafields.json"
                  payload={"metafield":{"namespace":"custom","key":"mpn","value":sku,"type":"single_line_text_field","owner_resource":"variant","owner_id":vid}}
                  rr=req("POST",mf_url,json=payload)
                  if not rr.ok and rr.status_code!=422:
                    print("metafield variant mpn error",vid,rr.status_code,rr.text)

              if total_inventory <= 2:
                add_tag_if_missing(pid, tags, "last-units")

              if PASS_MARK:
                upsert_product_metafield(pid, "custom", "processed_pass", PASS_MARK)

              processed+=1
              if SHOW_EVERY_ITEM:
                print(f"#{processed} PID={pid}  Procesados: {processed}", flush=True)
              elif PROGRESS_EVERY and processed % PROGRESS_EVERY == 0:
                elapsed=max(1,time.time()-start); rate=processed/elapsed
                print(f"Progreso: {processed} | Velocidad: {rate:.2f} prod/s", flush=True)

            page_info = next_page_info(r)
            if not page_info:
              print("Fin de paginación.", flush=True)
              break

          dur = time.time()-start
          print(f"FIN • Procesados: {processed} | Saltados: {skipped} | Tiempo: {dur/60:.1f} min", flush=True)
          PY
